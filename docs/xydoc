#!/usr/bin/env python3

from argparse import ArgumentParser
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional

# ---------------------------------------------------------------------------
# Data model
# ---------------------------------------------------------------------------


@dataclass
class Symbol:
    kind: str  # function, class, variable, method, operator
    name: str = ""
    signature: str = ""
    description: str = ""
    methods: List["Symbol"] = field(default_factory=list)


@dataclass
class ModuleDoc:
    name: str = ""
    header: str = ""
    description: str = ""
    symbols: List[Symbol] = field(default_factory=list)


# ---------------------------------------------------------------------------
# Lexer
# ---------------------------------------------------------------------------


@dataclass
class Token:
    type: str  # 'TAG' or 'TEXT'
    value: str
    line: int


def lex(lines: List[str]) -> List[Token]:
    tokens = []
    for i, line in enumerate(lines, start=1):
        stripped = line.strip()
        if stripped.startswith("@"):
            tokens.append(Token("TAG", stripped, i))
        elif stripped:
            tokens.append(Token("TEXT", line.rstrip("\n"), i))
        else:
            tokens.append(Token("TEXT", "", i))
    return tokens


# ---------------------------------------------------------------------------
# Parser
# ---------------------------------------------------------------------------


def parse(tokens: List[Token]) -> ModuleDoc:
    module = ModuleDoc()
    current_symbol: Optional[Symbol] = None
    current_class: Optional[Symbol] = None
    collecting_desc = None

    def flush_symbol():
        nonlocal current_symbol, current_class
        if current_symbol:
            if current_class and current_symbol.kind in ("method", "operator"):
                current_class.methods.append(current_symbol)
            else:
                module.symbols.append(current_symbol)
            current_symbol = None

    i = 0
    while i < len(tokens):
        t = tokens[i]
        if t.type == "TAG":
            flush_symbol()
            parts = t.value.split(maxsplit=2)
            tag = parts[0][1:]
            rest = parts[1:] if len(parts) > 1 else []

            if tag == "module":
                module.name = rest[0] if rest else ""
            elif tag == "header":
                module.header = " ".join(rest).strip('"')
            elif tag == "description":
                collecting_desc = "module"
                module.description = ""
            elif tag in ("function", "variable", "class", "method", "operator"):
                name_sig = " ".join(rest)
                name, sig = (name_sig.split("(", 1) + [""])[:2]
                if sig:
                    sig = "(" + sig
                current_symbol = Symbol(kind=tag, name=name.strip(), signature=sig)
                collecting_desc = "symbol"
                current_symbol.description = ""

                if tag == "class":
                    current_class = current_symbol
            elif tag == "endclass":
                flush_symbol()
                current_class = None
                collecting_desc = None
            else:
                collecting_desc = None
        else:  # TEXT
            if collecting_desc == "module":
                module.description += t.value + "\n"
            elif collecting_desc == "symbol" and current_symbol:
                current_symbol.description += t.value + "\n"
        i += 1

    flush_symbol()
    return module


# ---------------------------------------------------------------------------
# Markdown Renderer
# ---------------------------------------------------------------------------


def render_markdown(module: ModuleDoc) -> str:
    out = []
    out.append(f"# Module: `{module.name}`\n\n")
    if module.header:
        out.append(
            f'> **Header:** `{module.header}`  \n> **Import with:** `let {module.name} = import("{module.header}");`\n'
        )
    out.append("\n---\n\n## Overview\n\n")
    out.append(module.description.strip() + "\n\n---\n\n")

    # Grouping
    variables = [s for s in module.symbols if s.kind == "variable"]
    functions = [s for s in module.symbols if s.kind in ("function", "operator")]
    classes = [s for s in module.symbols if s.kind == "class"]

    out.append(
        "## Contents\n\n| Symbol | Type | Description |\n|:--------|:------|:-------------|\n"
    )

    def row(sym: Symbol):
        desc_line = sym.description.strip().split("\n", 1)[0]
        out.append(
            f"| [`{sym.name}`](#{sym.name.replace(" ", "-").lower()}) | {sym.kind} | {desc_line} |\n"
        )

    for group in (variables, functions, classes):
        for sym in group:
            row(sym)
            if sym.methods:
                for m in sym.methods:
                    desc_line = m.description.strip().split("\n", 1)[0]
                    out.append(
                        f"| [`{sym.name}::{m.name}`](#{sym.name.lower()}-{m.name.lower()}) | {m.kind} | {desc_line} |\n"
                    )

    out.append("\n---\n\n")

    # Detailed documentation
    def section(sym: Symbol, prefix=""):
        out.append(f"### {prefix}`{sym.name}`\n\n")
        if sym.signature:
            out.append(f"**Signature:** `{sym.name}{sym.signature}`  \n\n")
        out.append(sym.description.strip() + "\n\n")
        for m in sym.methods:
            section(m, prefix=f"{sym.name}::")

    for sym in variables + functions + classes:
        section(sym)

    return "".join(out)


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def main():
    parser = ArgumentParser(description="Generate Markdown docs from .xyd files.")
    parser.add_argument("files", nargs="+", help="Input .xyd files")
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        default=None,
        help="Output directory (defaults to same directory as input file)",
    )
    args = parser.parse_args()

    out_dir = Path(args.output) if args.output else None

    for fname in args.files:
        path = Path(fname)
        with open(path, "r", encoding="utf-8") as f:
            lines = f.readlines()
        tokens = lex(lines)
        module = parse(tokens)
        md = render_markdown(module)

        if out_dir:
            out_dir.mkdir(parents=True, exist_ok=True)
            out_path = out_dir / f"{path.stem}.md"
        else:
            out_path = path.with_suffix(".md")

        with open(out_path, "w", encoding="utf-8") as f:
            f.write(md)

        print(f"Generated {out_path}")


if __name__ == "__main__":
    main()
