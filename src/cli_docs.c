#include "cli.h"
#include "docs.h"
#include "memory.h"
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// Check if a path is a directory
static bool is_directory(const char *path) {
  struct stat statbuf;
  if (stat(path, &statbuf) != 0) {
    return false;
  }
  return S_ISDIR(statbuf.st_mode);
}

// Check if a file has .xyl extension
static bool is_xylia_file(const char *filename) {
  const char *ext = strrchr(filename, '.');
  return ext && strcmp(ext, ".xyl") == 0;
}

// Create directory if it doesn't exist
static bool ensure_directory(const char *path) {
  struct stat st = {0};
  if (stat(path, &st) == -1) {
    if (mkdir(path, 0755) == -1) {
      return false;
    }
  }
  return true;
}

// Process a single file
static bool process_file(const char *input_path, const doc_options_t *options,
                         cli_context_t *ctx) {
  if (ctx->verbose) {
    printf("Processing file: %s\n", input_path);
  }

  // Read the source file
  char *source = read_file(input_path);
  if (!source) {
    fprintf(stderr, "Error: Could not read file '%s'\n", input_path);
    return false;
  }

  // Extract documentation
  doc_module_t *module = extract_docs_from_source(source, input_path);
  free(source);

  if (!module) {
    fprintf(stderr, "Error: Failed to extract documentation from '%s'\n",
            input_path);
    return false;
  }

  // Generate documentation
  bool success = generate_docs(module, options);

  if (success && ctx->verbose) {
    printf("Generated documentation for: %s\n", module->name);
  } else if (!success) {
    fprintf(stderr, "Error: Failed to generate documentation for '%s'\n",
            input_path);
  }

  doc_module_free(module);
  return success;
}

// Process all .xyl files in a directory
static bool process_directory(const char *input_dir,
                              const doc_options_t *options,
                              cli_context_t *ctx) {
  DIR *dir = opendir(input_dir);
  if (!dir) {
    fprintf(stderr, "Error: Could not open directory '%s'\n", input_dir);
    return false;
  }

  bool success = true;
  struct dirent *entry;

  while ((entry = readdir(dir)) != NULL) {
    if (entry->d_name[0] == '.')
      continue; // Skip hidden files

    char full_path[1024];
    snprintf(full_path, sizeof(full_path), "%s/%s", input_dir, entry->d_name);

    if (is_xylia_file(entry->d_name)) {
      if (!process_file(full_path, options, ctx)) {
        success = false;
      }
    } else if (is_directory(full_path)) {
      // Recursively process subdirectories
      if (!process_directory(full_path, options, ctx)) {
        success = false;
      }
    }
  }

  closedir(dir);
  return success;
}

// Generate markdown index file
static bool generate_index_markdown(const char *output_dir,
                                    const doc_options_t *options,
                                    cli_context_t *ctx) {
  char index_path[1024];
  snprintf(index_path, sizeof(index_path), "%s/index.md", output_dir);

  FILE *f = fopen(index_path, "w");
  if (!f) {
    fprintf(stderr, "Error: Could not create index file '%s'\n", index_path);
    return false;
  }

  fprintf(f, "# %s\n\n", options->title ? options->title : "Documentation");
  fprintf(f, "This documentation was generated automatically from Xylia source "
             "files.\n\n");
  fprintf(f, "## Modules\n\n");

  // Scan output directory for generated documentation files
  DIR *dir = opendir(output_dir);
  if (dir) {
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
      if (entry->d_name[0] == '.')
        continue;

      const char *ext = strrchr(entry->d_name, '.');
      if (ext && strcmp(ext, ".md") == 0 &&
          strcmp(entry->d_name, "index.md") != 0) {
        // Remove .md extension for display
        char module_name[256];
        size_t name_len = ext - entry->d_name;
        strncpy(module_name, entry->d_name, name_len);
        module_name[name_len] = '\0';

        fprintf(f, "- [%s](%s)\n", module_name, entry->d_name);
      }
    }
    closedir(dir);
  }

  fprintf(f, "\n---\n\n");
  fprintf(f, "*Generated by Xylia docs v%s*\n", XYLIA_VERSION_STRING);

  fclose(f);

  if (ctx->verbose) {
    printf("Generated index file: %s\n", index_path);
  }

  return true;
}

// Generate HTML index file
static bool generate_index_html(const char *output_dir,
                                const doc_options_t *options,
                                cli_context_t *ctx) {
  char index_path[1024];
  snprintf(index_path, sizeof(index_path), "%s/index.html", output_dir);

  FILE *f = fopen(index_path, "w");
  if (!f) {
    fprintf(stderr, "Error: Could not create index file '%s'\n", index_path);
    return false;
  }

  // Write HTML header
  fprintf(f, "<!DOCTYPE html>\n");
  fprintf(f, "<html lang=\"en\">\n");
  fprintf(f, "<head>\n");
  fprintf(f, "    <meta charset=\"UTF-8\">\n");
  fprintf(f, "    <meta name=\"viewport\" content=\"width=device-width, "
             "initial-scale=1.0\">\n");
  fprintf(f, "    <title>%s</title>\n",
          options->title ? options->title : "Documentation");
  fprintf(f, "    <style>\n");
  fprintf(f, "        body { font-family: -apple-system, BlinkMacSystemFont, "
             "'Segoe UI', Roboto, sans-serif; }\n");
  fprintf(f, "        .container { max-width: 1200px; margin: 0 auto; padding: "
             "20px; }\n");
  fprintf(f, "        .header { border-bottom: 1px solid #e1e5e9; "
             "margin-bottom: 30px; padding-bottom: 20px; }\n");
  fprintf(f, "        .modules { display: grid; grid-template-columns: "
             "repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; }\n");
  fprintf(f, "        .module-card { border: 1px solid #e1e5e9; border-radius: "
             "6px; padding: 20px; background: #fff; }\n");
  fprintf(f, "        .module-card:hover { box-shadow: 0 2px 8px "
             "rgba(0,0,0,0.1); }\n");
  fprintf(f,
          "        .module-card h3 { margin: 0 0 10px 0; color: #0366d6; }\n");
  fprintf(
      f, "        .module-card a { text-decoration: none; color: inherit; }\n");
  fprintf(f,
          "        .footer { margin-top: 50px; padding-top: 20px; border-top: "
          "1px solid #e1e5e9; color: #586069; text-align: center; }\n");
  fprintf(f, "        h1 { color: #24292e; }\n");
  fprintf(f, "    </style>\n");
  fprintf(f, "</head>\n");
  fprintf(f, "<body>\n");
  fprintf(f, "    <div class=\"container\">\n");
  fprintf(f, "        <div class=\"header\">\n");
  fprintf(f, "            <h1>%s</h1>\n",
          options->title ? options->title : "Documentation");
  fprintf(f, "            <p>This documentation was generated automatically "
             "from Xylia source files.</p>\n");
  fprintf(f, "        </div>\n");
  fprintf(f, "        <h2>Modules</h2>\n");
  fprintf(f, "        <div class=\"modules\">\n");

  // Scan output directory for generated documentation files
  DIR *dir = opendir(output_dir);
  if (dir) {
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
      if (entry->d_name[0] == '.')
        continue;

      const char *ext = strrchr(entry->d_name, '.');
      if (ext && strcmp(ext, ".html") == 0 &&
          strcmp(entry->d_name, "index.html") != 0) {
        // Remove .html extension for display
        char module_name[256];
        size_t name_len = ext - entry->d_name;
        strncpy(module_name, entry->d_name, name_len);
        module_name[name_len] = '\0';

        fprintf(f, "            <div class=\"module-card\">\n");
        fprintf(f, "                <a href=\"%s\">\n", entry->d_name);
        fprintf(f, "                    <h3>%s</h3>\n", module_name);
        fprintf(f, "                    <p>Module documentation</p>\n");
        fprintf(f, "                </a>\n");
        fprintf(f, "            </div>\n");
      }
    }
    closedir(dir);
  }

  fprintf(f, "        </div>\n");
  fprintf(f, "        <div class=\"footer\">\n");
  fprintf(f, "            <p>Generated by Xylia docs v%s</p>\n",
          XYLIA_VERSION_STRING);
  fprintf(f, "        </div>\n");
  fprintf(f, "    </div>\n");
  fprintf(f, "</body>\n");
  fprintf(f, "</html>\n");

  fclose(f);

  if (ctx->verbose) {
    printf("Generated index file: %s\n", index_path);
  }

  return true;
}

// Generate index file for all documentation
static bool generate_index(const char *output_dir, const doc_options_t *options,
                           cli_context_t *ctx) {
  switch (options->format) {
  case DOC_FORMAT_MARKDOWN:
    return generate_index_markdown(output_dir, options, ctx);
  case DOC_FORMAT_HTML:
    return generate_index_html(output_dir, options, ctx);
  default:
    return false;
  }
}

// Show help for docs subcommand
static void show_docs_help(void) {
  printf("Usage: xylia docs [OPTIONS] <input>\n\n");
  printf("Generate documentation from Xylia source files.\n\n");
  printf("Arguments:\n");
  printf("  <input>              Input file or directory\n\n");
  printf("Options:\n");
  printf("  -o, --output DIR     Output directory (default: ./docs)\n");
  printf("  -f, --format FORMAT  Output format: markdown, html (default: "
         "markdown)\n");
  printf("  -t, --title TITLE    Documentation title\n");
  printf("  --no-index           Don't generate index file\n");
  printf("  --include-private    Include private members\n");
  printf("  -h, --help           Show this help message\n\n");
  printf("Examples:\n");
  printf("  xylia docs main.xyl                 # Generate docs for single "
         "file\n");
  printf(
      "  xylia docs src/                     # Generate docs for directory\n");
  printf("  xylia docs -o ./output src/         # Specify output directory\n");
  printf("  xylia docs -f html --title \"My Docs\" src/  # HTML format with "
         "title\n");
}

// Main docs CLI function
cli_result_t cli_docs(int argc, char **argv, cli_context_t *ctx) {
  // Default options
  doc_options_t options = {.format = DOC_FORMAT_MARKDOWN,
                           .output_dir = strdup("./docs"),
                           .include_private = false,
                           .generate_index = true,
                           .title = NULL,
                           .theme = NULL};

  const char *input_path = NULL;

  // Parse arguments
  for (int i = 0; i < argc; i++) {
    const char *arg = argv[i];

    if (strcmp(arg, "-h") == 0 || strcmp(arg, "--help") == 0) {
      show_docs_help();
      free(options.output_dir);
      return CLI_SUCCESS;
    } else if (strcmp(arg, "-o") == 0 || strcmp(arg, "--output") == 0) {
      if (i + 1 >= argc) {
        fprintf(stderr, "Error: %s requires an argument\n", arg);
        free(options.output_dir);
        return CLI_INVALID_ARGS;
      }
      free(options.output_dir);
      options.output_dir = strdup(argv[++i]);
    } else if (strcmp(arg, "-f") == 0 || strcmp(arg, "--format") == 0) {
      if (i + 1 >= argc) {
        fprintf(stderr, "Error: %s requires an argument\n", arg);
        free(options.output_dir);
        return CLI_INVALID_ARGS;
      }
      const char *format = argv[++i];
      if (strcmp(format, "markdown") == 0 || strcmp(format, "md") == 0) {
        options.format = DOC_FORMAT_MARKDOWN;
      } else if (strcmp(format, "html") == 0) {
        options.format = DOC_FORMAT_HTML;
      } else if (strcmp(format, "json") == 0) {
        options.format = DOC_FORMAT_JSON;
      } else {
        fprintf(stderr, "Error: Unknown format '%s'\n", format);
        free(options.output_dir);
        return CLI_INVALID_ARGS;
      }
    } else if (strcmp(arg, "-t") == 0 || strcmp(arg, "--title") == 0) {
      if (i + 1 >= argc) {
        fprintf(stderr, "Error: %s requires an argument\n", arg);
        free(options.output_dir);
        return CLI_INVALID_ARGS;
      }
      options.title = argv[++i];
    } else if (strcmp(arg, "--no-index") == 0) {
      options.generate_index = false;
    } else if (strcmp(arg, "--include-private") == 0) {
      options.include_private = true;
    } else if (arg[0] == '-') {
      fprintf(stderr, "Error: Unknown option '%s'\n", arg);
      free(options.output_dir);
      return CLI_INVALID_ARGS;
    } else {
      if (input_path) {
        fprintf(stderr, "Error: Multiple input paths specified\n");
        free(options.output_dir);
        return CLI_INVALID_ARGS;
      }
      input_path = arg;
    }
  }

  // Validate input
  if (!input_path) {
    fprintf(stderr, "Error: No input file or directory specified\n");
    fprintf(stderr, "Run 'xylia docs --help' for usage information\n");
    free(options.output_dir);
    return CLI_INVALID_ARGS;
  }

  // Check if input exists
  if (access(input_path, R_OK) != 0) {
    fprintf(stderr, "Error: Cannot read input '%s'\n", input_path);
    free(options.output_dir);
    return CLI_ERROR;
  }

  // Create output directory
  if (!ensure_directory(options.output_dir)) {
    fprintf(stderr, "Error: Could not create output directory '%s'\n",
            options.output_dir);
    free(options.output_dir);
    return CLI_ERROR;
  }

  if (ctx->verbose) {
    printf("Generating documentation...\n");
    printf("Input: %s\n", input_path);
    printf("Output: %s\n", options.output_dir);
    printf("Format: %s\n", options.format == DOC_FORMAT_MARKDOWN ? "markdown"
                           : options.format == DOC_FORMAT_HTML   ? "html"
                                                                 : "json");
  }

  // Process input
  bool success;
  if (is_directory(input_path)) {
    success = process_directory(input_path, &options, ctx);
  } else {
    success = process_file(input_path, &options, ctx);
  }

  // Generate index if requested and successful
  if (success && options.generate_index) {
    success = generate_index(options.output_dir, &options, ctx);
  }

  if (success) {
    printf("Documentation generated successfully in '%s'\n",
           options.output_dir);
  }

  free(options.output_dir);
  return success ? CLI_SUCCESS : CLI_ERROR;
}